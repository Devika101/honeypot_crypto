"""Vulnerability injection module for honeypot services.

Manages realistic CVE-like vulnerabilities that can be injected into honeypot
services. Vulnerabilities are discoverable but not trivially exploitable,
and all exploitation attempts are logged with full context.

Vulnerability types:
- SQL Injection endpoints
- Command injection flaws
- Weak authentication
- Outdated software fingerprints
- Directory traversal
"""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Optional

from src.utils.logger import get_logger

logger = get_logger(__name__)


class VulnType(Enum):
    """Categories of injectable vulnerabilities."""

    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    WEAK_AUTH = "weak_auth"
    OUTDATED_SOFTWARE = "outdated_software"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    XSS = "xss"


class Severity(Enum):
    """CVSS-like severity levels."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class VulnerabilityTemplate:
    """Defines a vulnerability that can be injected into a service.

    Attributes:
        vuln_id: Unique identifier (e.g., "DNET-001").
        vuln_type: Category of vulnerability.
        severity: CVSS-like severity.
        target_service: Which service this applies to (ssh, http, ftp, etc.).
        description: Human-readable description.
        detection_signature: Regex pattern that indicates exploitation attempt.
        response_template: What to return when the vuln is triggered.
        metadata: Additional info (fake CVE ID, affected version, etc.).
    """

    vuln_id: str
    vuln_type: VulnType
    severity: Severity
    target_service: str
    description: str
    detection_signature: str
    response_template: str
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitAttempt:
    """Records a detected exploitation attempt."""

    vuln_id: str
    vuln_type: str
    source_ip: str
    payload: str
    matched_signature: str
    timestamp: str = ""


# Built-in vulnerability template library
VULN_TEMPLATES: list[VulnerabilityTemplate] = [
    VulnerabilityTemplate(
        vuln_id="DNET-001",
        vuln_type=VulnType.SQL_INJECTION,
        severity=Severity.HIGH,
        target_service="http",
        description="SQL injection in search parameter",
        detection_signature=r"('|--|;|UNION|SELECT|DROP|INSERT|UPDATE|DELETE|OR\s+1\s*=\s*1)",
        response_template=(
            "MySQL Error: You have an error in your SQL syntax; "
            "check the manual that corresponds to your MySQL server version "
            "for the right syntax to use near '{payload}' at line 1"
        ),
        metadata={"fake_cve": "CVE-2023-XXXX", "affected_component": "search_api"},
    ),
    VulnerabilityTemplate(
        vuln_id="DNET-002",
        vuln_type=VulnType.COMMAND_INJECTION,
        severity=Severity.CRITICAL,
        target_service="http",
        description="OS command injection via ping utility",
        detection_signature=r"(;|\||`|\$\(|&&)",
        response_template="PING {payload}: 56 data bytes\n64 bytes from 127.0.0.1: icmp_seq=1 ttl=64",
        metadata={"fake_cve": "CVE-2023-YYYY", "affected_component": "network_tools"},
    ),
    VulnerabilityTemplate(
        vuln_id="DNET-003",
        vuln_type=VulnType.WEAK_AUTH,
        severity=Severity.MEDIUM,
        target_service="ssh",
        description="Default credentials on SSH service",
        detection_signature=r"^(admin|root|test|guest|user)$",
        response_template="Authentication successful",
        metadata={"default_accounts": ["admin:admin123", "root:toor"]},
    ),
    VulnerabilityTemplate(
        vuln_id="DNET-004",
        vuln_type=VulnType.OUTDATED_SOFTWARE,
        severity=Severity.LOW,
        target_service="http",
        description="Outdated Apache version with known CVEs",
        detection_signature=r"(HEAD|GET|OPTIONS)\s+/",
        response_template="Server: Apache/2.4.49",
        metadata={"real_cve": "CVE-2021-41773", "note": "Path traversal in Apache 2.4.49"},
    ),
    VulnerabilityTemplate(
        vuln_id="DNET-005",
        vuln_type=VulnType.DIRECTORY_TRAVERSAL,
        severity=Severity.HIGH,
        target_service="http",
        description="Directory traversal via file path parameter",
        detection_signature=r"(\.\./|\.\.\\|%2e%2e|%252e)",
        response_template="root:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin",
        metadata={"fake_cve": "CVE-2023-ZZZZ"},
    ),
    VulnerabilityTemplate(
        vuln_id="DNET-006",
        vuln_type=VulnType.XSS,
        severity=Severity.MEDIUM,
        target_service="http",
        description="Reflected XSS in comment field",
        detection_signature=r"(<script|javascript:|on\w+=|<img\s+src)",
        response_template='<div class="comment">{payload}</div>',
        metadata={"type": "reflected_xss"},
    ),
    VulnerabilityTemplate(
        vuln_id="DNET-007",
        vuln_type=VulnType.WEAK_AUTH,
        severity=Severity.HIGH,
        target_service="ftp",
        description="Anonymous FTP access with sensitive files",
        detection_signature=r"^anonymous$",
        response_template="230 Anonymous login ok.",
        metadata={"exposed_files": ["backup.sql.gz", "credentials.txt"]},
    ),
]


class VulnerabilityInjector:
    """Manages vulnerability injection and exploitation detection.

    Maintains a registry of active vulnerabilities and checks incoming
    requests/interactions against their detection signatures.
    """

    def __init__(self, templates: Optional[list[VulnerabilityTemplate]] = None) -> None:
        self._templates: dict[str, VulnerabilityTemplate] = {}
        self._service_vulns: dict[str, list[VulnerabilityTemplate]] = {}
        self.exploit_attempts: list[ExploitAttempt] = []

        for tmpl in (templates or VULN_TEMPLATES):
            self.register(tmpl)

    def register(self, template: VulnerabilityTemplate) -> None:
        """Register a vulnerability template."""
        self._templates[template.vuln_id] = template
        self._service_vulns.setdefault(template.target_service, []).append(template)
        logger.debug(
            "Vulnerability registered",
            vuln_id=template.vuln_id,
            service=template.target_service,
            type=template.vuln_type.value,
        )

    def get_vulns_for_service(self, service: str) -> list[VulnerabilityTemplate]:
        """Get all vulnerability templates for a given service."""
        return self._service_vulns.get(service, [])

    def check_exploit(
        self,
        service: str,
        payload: str,
        source_ip: str = "unknown",
    ) -> Optional[ExploitAttempt]:
        """Check if a payload matches any vulnerability signatures for a service.

        Args:
            service: Service name (ssh, http, ftp, etc.).
            payload: The input/request data to check.
            source_ip: Source IP of the request.

        Returns:
            ExploitAttempt if a match is found, None otherwise.
        """
        for vuln in self.get_vulns_for_service(service):
            if re.search(vuln.detection_signature, payload, re.IGNORECASE):
                attempt = ExploitAttempt(
                    vuln_id=vuln.vuln_id,
                    vuln_type=vuln.vuln_type.value,
                    source_ip=source_ip,
                    payload=payload,
                    matched_signature=vuln.detection_signature,
                )
                self.exploit_attempts.append(attempt)

                logger.warning(
                    "Exploit attempt detected",
                    vuln_id=vuln.vuln_id,
                    vuln_type=vuln.vuln_type.value,
                    source_ip=source_ip,
                    severity=vuln.severity.value,
                )

                return attempt

        return None

    def get_response(self, vuln_id: str, payload: str = "") -> str:
        """Get the fake response for a triggered vulnerability.

        Args:
            vuln_id: The vulnerability template ID.
            payload: The attacker's payload (for template substitution).

        Returns:
            The response string to send back to the attacker.
        """
        template = self._templates.get(vuln_id)
        if not template:
            return ""
        return template.response_template.format(payload=payload)

    def get_stats(self) -> dict[str, Any]:
        """Get summary statistics of exploitation attempts."""
        by_type: dict[str, int] = {}
        by_source: dict[str, int] = {}
        by_vuln: dict[str, int] = {}

        for attempt in self.exploit_attempts:
            by_type[attempt.vuln_type] = by_type.get(attempt.vuln_type, 0) + 1
            by_source[attempt.source_ip] = by_source.get(attempt.source_ip, 0) + 1
            by_vuln[attempt.vuln_id] = by_vuln.get(attempt.vuln_id, 0) + 1

        return {
            "total_attempts": len(self.exploit_attempts),
            "by_type": by_type,
            "by_source": by_source,
            "by_vulnerability": by_vuln,
        }
